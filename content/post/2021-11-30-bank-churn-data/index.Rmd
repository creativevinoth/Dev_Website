---
title: Bank_Churn_Data
author: ''
date: '2021-11-30'
slug: bank-churn-data
categories: []
tags: []
---
```{r message = FALSE, warning = FALSE, echo = FALSE}

library(ggplot2)
library(dplyr)
library(data.table)
library(tidyr)
library(GGally)
library(gapminder)
library(tidyverse)
library(pastecs)
library(ggpubr)
library(fastDummies)
library(QuantPsyc)
library(MASS)
library(caret)
library(leaps)
library(summarytools)
library(epiDisplay)
library(tidymodels)
library(Rmisc)
library(Amelia)
library(ranger)
```

```{r message = FALSE, warning = FALSE, echo = FALSE, include = FALSE}
Bank_Churn_Data <- read.csv("Bank_Churn_Data.csv")
```

```{r}
summary(Bank_Churn_Data)
```

We can remove 2 variables rownumber and customerid as they are related to individual

# Removing rownumber and customerid
```{r}
Bank_Churn_Data <- subset (Bank_Churn_Data, select = - RowNumber)
Bank_Churn_Data <- subset (Bank_Churn_Data, select = - CustomerId)
```

# Structure of data
```{r}
str(Bank_Churn_Data)
```
The exited, hascrcard and isactivemember are categorical value but wrongly taken as integer varaiable

# Chaning the variable from int to character
```{r}
Bank_Churn_Data$HasCrCard = factor(Bank_Churn_Data$HasCrCard)
Bank_Churn_Data$IsActiveMember = factor(Bank_Churn_Data$IsActiveMember)
Bank_Churn_Data$Exited  = factor(Bank_Churn_Data$Exited )
```

# Descriptive statistics
```{r}
descr(Bank_Churn_Data)
```
# Revised structure
```{r}
str(Bank_Churn_Data)
```
# Univariate analysis on numerical data

# Univariate analysis on Age
```{r}
descr(Bank_Churn_Data$Age)
```

# Boxplot of age and its outliers

```{r}
Age_outliers_churn<-boxplot.stats(Bank_Churn_Data$Age)$out
boxplot(Bank_Churn_Data$Age, main = "Box plot of age", boxwex = 0.6)
mtext(paste("Outliers: ", paste(Age_outliers_churn, collapse =", ")), cex = 0.6)
Age_outliers_churn
```
The above box plot shows that the age above 63 are outliers. so, we remove those values from the dataset

# Removal of outliers of age
```{r}
Bank_Churn_Data <- subset (Bank_Churn_Data, Age < 63)
```

# Univariate analysis on Balance
```{r}
descr(Bank_Churn_Data$Balance)
```
# Boxplot of Balance and its outliers

```{r}
Balance_outliers_churn<-boxplot.stats(Bank_Churn_Data$Balance)$out
boxplot(Bank_Churn_Data$Balance, main = "Box plot of Balance", boxwex = 0.6)
mtext(paste("Outliers: ", paste(Balance_outliers_churn, collapse =", ")), cex = 0.6)
Balance_outliers_churn
```
There are no outliers

# Univariate analysis on CreditScore
```{r}
descr(Bank_Churn_Data$CreditScore)
```
# Boxplot of CreditScore and its outliers
```{r}
CreditScore_outliers_churn<-boxplot.stats(Bank_Churn_Data$CreditScore)$out
boxplot(Bank_Churn_Data$CreditScore, main = "Box plot of CreditScore", boxwex = 0.6)
mtext(paste("Outliers: ", paste(CreditScore_outliers_churn, collapse =", ")), cex = 0.6)
CreditScore_outliers_churn
```
We can see that less than 376 credit score are outliers. So, we remove those values from the dataset.

# Removal of outliers of CreditScore
```{r}
Bank_Churn_Data <- subset (Bank_Churn_Data, CreditScore > 376)
```

# Univariate analysis on EstimatedSalary
```{r}
descr(Bank_Churn_Data$EstimatedSalary)
```

# Boxplot of EstimatedSalary and its outliers
```{r}
EstimatedSalary_outliers_churn<-boxplot.stats(Bank_Churn_Data$EstimatedSalary)$out
boxplot(Bank_Churn_Data$EstimatedSalary, main = "Box plot of EstimatedSalary", boxwex = 0.6)
mtext(paste("Outliers: ", paste(EstimatedSalary_outliers_churn, collapse =", ")), cex = 0.6)
EstimatedSalary_outliers_churn
```
There are no outliers

# Univariate analysis on NumOfProducts
```{r}
descr(Bank_Churn_Data$NumOfProducts)
```

# Boxplot of NumOfProducts and its outliers
```{r}
NumOfProducts_outliers_churn<-boxplot.stats(Bank_Churn_Data$NumOfProducts)$out
boxplot(Bank_Churn_Data$NumOfProducts, main = "Box plot of NumOfProducts", boxwex = 0.6)
mtext(paste("Outliers: ", paste(NumOfProducts_outliers_churn, collapse =", ")), cex = 0.6)
NumOfProducts_outliers_churn
```
We can see that there are few people having 4 products and it is an outliers here. SO, we remove it from the dataset

# Removal of outliers of NumOfProducts
```{r}
Bank_Churn_Data <- subset (Bank_Churn_Data, NumOfProducts < 4)
```

# Univariate analysis on Tenure
```{r}
descr(Bank_Churn_Data$Tenure)
```

# Boxplot of Tenure and its outliers
```{r}
Tenure_outliers_churn<-boxplot.stats(Bank_Churn_Data$Tenure)$out
boxplot(Bank_Churn_Data$Tenure, main = "Box plot of Tenure", boxwex = 0.6)
mtext(paste("Outliers: ", paste(Tenure_outliers_churn, collapse =", ")), cex = 0.6)
Tenure_outliers_churn
```
There are no outliers for tenure

# Univariate analysis on categorical values

I analyzed the categorical values using frequency distribution to figure out least distribution among the distributed values.

# Frequency distribution of Geography
```{r}
tab1(Bank_Churn_Data$Geography, sort.group = "increasing", cum.percent = TRUE, main = "Frequency distribution of Geography", xlab ="Geography")
```

# Frequency distribution of Gender
```{r}
tab1(Bank_Churn_Data$Gender, sort.group = "increasing", cum.percent = TRUE, main = "Frequency distribution of Gender", xlab ="Gender")
```
There are more people having account with bank compared to female members

# Frequency distribution of HasCrCard

```{r}
tab1(Bank_Churn_Data$HasCrCard, sort.group = "increasing", cum.percent = TRUE, main = "Frequency distribution of HasCrCard", xlab ="HasCrCard")
```

Around 70% of customers have a credit card with bank and only 30% of people without credit card

# Frequency distribution of IsActiveMember

```{r}
tab1(Bank_Churn_Data$IsActiveMember, sort.group = "increasing", cum.percent = TRUE, main = "Frequency distribution of IsActiveMember", xlab ="IsActiveMember")
```
Almost 50% of customer are not actively making transaction in bank. 

# Frequency distribution of Exited 
```{r}
tab1(Bank_Churn_Data$Exited , sort.group = "increasing", cum.percent = TRUE, main = "Frequency distribution of Exited ", xlab ="Exited ")
```
We could see from the above frequency distribution that only 20% of customers was a loyal customer and approximately 80% of customers closed the bank account

# Bivariate analysis to see the relationship between dependant and independant variable
Here, we will analyze the relationship between response and explanatory variables.


# Relationship between Exited and Age
```{r}
Age_Exited = glm(Exited~ Age, data = Bank_Churn_Data, family = "binomial")
summary(Age_Exited)
```
There is a significant relationship between age and exited

```{r}
discretized.Age = cut(Bank_Churn_Data$Age, c(0, 10, 20, 30, 40, 50, 60,70))
ggplot(Bank_Churn_Data, aes(x = discretized.Age , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```

# Relationship between Exited and Balance
```{r}
Balance_Exited = glm(Exited~ Balance, data = Bank_Churn_Data, family = "binomial")
summary(Balance_Exited)
```
There is a significant relationship between balance and exited

```{r}
discretized.Balance = cut(Bank_Churn_Data$Balance, c(0, 50000, 100000, 150000, 200000, 250000, 300000))
ggplot(Bank_Churn_Data, aes(x = discretized.Balance , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```
######################################Have to check the above error

# Relationship between Exited and CreditScore
```{r}
CreditScore_Exited = glm(Exited~ CreditScore, data = Bank_Churn_Data, family = "binomial")
summary(Balance_Exited)
```
The credit score is significant to predict the exited

```{r}
discretized.CreditScore = cut(Bank_Churn_Data$CreditScore, c(0,400, 500, 600, 700, 800, 900))
ggplot(Bank_Churn_Data, aes(x = discretized.CreditScore , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```
We can infer from the above bar chart that more people are churned when the credit score is between 600 and 700.

# Relationship between Exited and EstimatedSalary
```{r}
EstimatedSalary_Exited = glm(Exited~ EstimatedSalary, data = Bank_Churn_Data, family = "binomial")
summary(EstimatedSalary_Exited)
```
The coefficient of the estimated salary are not significant to predict the exited


```{r}
discretized.EstimatedSalary = cut(Bank_Churn_Data$EstimatedSalary, c(0,40000, 80000, 120000, 160000, 200000))
ggplot(Bank_Churn_Data, aes(x = discretized.EstimatedSalary , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```
################################################### have to check the error

# Relationship between Exited and NumOfProducts
```{r}
NumOfProducts_Exited = glm(Exited~ NumOfProducts, data = Bank_Churn_Data, family = "binomial")
summary(NumOfProducts_Exited)
```
The number of bank products held by customers has a significant relationship to predict the customers exited

```{r}
ggplot(Bank_Churn_Data, aes(x = NumOfProducts , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```
The percentage of the churn rate for customer having 1 and 2 account having more churn rate comparedd to customer having 3 products

# Relationship between Exited and Tenure
```{r}
Tenure_Exited = glm(Exited~ Tenure, data = Bank_Churn_Data, family = "binomial")
summary(Tenure_Exited)
```
The coefficient of the tenure is not significant to predict the exited

```{r}
ggplot(Bank_Churn_Data, aes(x = Tenure , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```
It is surprising to see that 828 customer after having 7 years of relationship with bank, that was the highest churn numbers among different tenures.

# Relationship between Exited and Geography

```{r}
Geography_Exited = glm(Exited~ Geography, data = Bank_Churn_Data, family = "binomial")
summary(Geography_Exited)
```

There is no significant relationship between geography and exited due to some of the coefficients are not significant


```{r}
ggplot(Bank_Churn_Data, aes(x = Geography , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```
France has the highest churn rate of customers among others. Almost 85% of the customer closed the account.

# Relationship between Exited and Gender

```{r}
Gender_Exited = glm(Exited~ Gender, data = Bank_Churn_Data, family = "binomial")
summary(Gender_Exited)
```
There is a significant relationship between gender and exited

```{r}
ggplot(Bank_Churn_Data, aes(x = Gender , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```

There is a highest churn rate with male customer with approximate churn percentage of 84% as against female churn rate of 75% approximately.

# Relationship between Exited and HasCrCard

```{r}
HasCrCard_Exited = glm(Exited~ HasCrCard, data = Bank_Churn_Data, family = "binomial")
summary(HasCrCard_Exited)
```
There is no significant relationship between the customer having credit card and exited because of its coefficients are not significant.

```{r}
ggplot(Bank_Churn_Data, aes(x = HasCrCard , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```
Almost 80% of customers closed the account irrespective of customers having credit card or not.

# Relationship between Exited and IsActiveMember

```{r}
IsActiveMember_Exited = glm(Exited~ IsActiveMember, data = Bank_Churn_Data, family = "binomial")
summary(IsActiveMember_Exited)
```
There is a significant relationship between IsActiveMember and Exited.

```{r}
ggplot(Bank_Churn_Data, aes(x = IsActiveMember , fill = Exited )) + geom_bar(position = position_dodge())+geom_text(stat = 'count', aes(label = stat(count)), position = position_dodge(width =1), vjust = -0.4)
```

It is surprising to notice that actively transacted customers(86%) have high percentage of churn rate against customers who have not transacted actively (75%)

# Full model logistic regression
```{r}
full_model_bank_churn = glm(Exited ~ ., family = "binomial", data = Bank_Churn_Data)
summary(full_model_bank_churn)
```
# Backward Regression

```{r}
mod_step_bank_churn<- stepAIC(full_model_bank_churn, direction = 'backward', trace = FALSE)
mod_step_bank_churn
```
# Bootstrap method
Using bootstrap re sampling with replacement method to access the consistency predictors selected with stepwise
```{r message = FALSE, warning = FALSE, echo = FALSE}
library(bootStepAIC)
```
```{r}
mod_boot_bank_churn<- boot.stepAIC(full_model_bank_churn, Bank_Churn_Data, B =50)
```

## Bootstrap summary

```{r}
print(mod_boot_bank_churn)
```

# Best model by backward and bootstrap method
```{r}
best_bootmodel_bank_churn<- glm(formula = Exited ~ Geography + Gender + Age + Tenure + Balance + NumOfProducts + 
    IsActiveMember, family = "binomial", 
    data = Bank_Churn_Data)
summary(best_bootmodel_bank_churn) 
```
We could see in the above selected bootstrap and stepwise regression model that some of the coefficients such as geography and tenure are not significant. SO to get better significant model, geography and tenure are to be removed.

# Best model after many iterations
```{r}
bestmodel<- glm(formula = Exited ~  Gender + Age + Balance + NumOfProducts + 
    IsActiveMember, family = "binomial", 
    data = Bank_Churn_Data)
summary(bestmodel)
```
The above is the best model after many iterations as all the coefficients are 99.9% significant to predict the response variable exited. 

# Data resampling
```{r}
bank_churn_split <- initial_split (Bank_Churn_Data, prop = 0.80, strata = Exited)
bank_churn_training <- bank_churn_split %>%
  training()
bank_churn_test <- bank_churn_split %>%
  testing()
```

We have taken 80:20 split for data sampling. We have made training data to fit the model and test the model using test set.

# Checking number of rows in training and test data

```{r}
nrow(bank_churn_training)
nrow(bank_churn_test)
```
There are total 7654 numbers of row in training data and 1915 numbers of row in test data.

# Checking multicollinearity between numerical values in a training bank churn data set
```{r}
bank_churn_training %>%
  select_if(is.numeric) %>%
  cor()
```

There is no multi-colinearity between the independent numeric variables.


# Future engineering
This is the step to pre-processing of data
```{r}
bank_churn_recipe <- recipe(Exited ~ ., data = bank_churn_training) %>%
  step_corr(all_numeric(), threshold =0.8) %>%
  step_normalize(all_numeric()) %>%
  step_dummy(all_nominal(), -all_outcomes())
bank_churn_recipe
```
There are 10 predictor variable and 1 outcome variable.

# Recipe training
```{r}
bank_churn_recipe_prep<- bank_churn_recipe %>%
  prep(training = bank_churn_training)
bank_churn_recipe_prep
```
We have prepared the training data set.

# Preprocess training data
```{r}
bank_churn_training_prep <- bank_churn_recipe_prep %>%
  bake (new_data = NULL)
bank_churn_training_prep
```
We have pre-processed the training data set.

# Preprocess test data
```{r}
bank_churn_test_prep <- bank_churn_recipe_prep %>%
  bake (new_data = bank_churn_test)
bank_churn_test_prep
```

We pre-processed the test data.

# Machine learning models using logistic regression
I specify the logistic regression model here
```{r}
bank_churn_logistic_model<- logistic_reg() %>%
  set_engine('glm') %>%
  set_mode('classification')
```

# Model fitting

```{r}
bank_churn_logistic_fit <- bank_churn_logistic_model %>%
  fit(Exited ~ ., data = bank_churn_training_prep)
bank_churn_logistic_fit
```

# Predicting outcome categories

```{r}
bank_churn_logistic_class_preds <- predict (bank_churn_logistic_fit, new_data = bank_churn_test_prep, type ="class")
bank_churn_logistic_class_preds
```

The above .pred class is the outcome of our results. That is if the customer will churn or not. The number o means churn and 1 means no churn.

# Estimated probabilities

```{r}
bank_churn_logistic_prob_preds <- predict (bank_churn_logistic_fit, new_data = bank_churn_test_prep, type ="prob")
bank_churn_logistic_prob_preds
```
The above prediction are the probabilities of outcome occurrences.


# Combining results

```{r}
bank_churn_logistic_results <- bank_churn_test_prep %>%
  bind_cols(bank_churn_logistic_class_preds, bank_churn_logistic_prob_preds)
bank_churn_logistic_results
```
# Assessing the model fit using Confusion matrix


```{r}
bank_churn_logistic_results %>%
  conf_mat(truth = Exited, estimate = .pred_class) %>%
  autoplot(type = 'heatmap')
```
# Correct predictions of test set
True negative is 1483 customers, who churned. True positive is 120 people, who was a loyal customer and did not churn. 

# Classification error of test set
False positive is 53 people, who are predicted as not churned but actually churned. False negative is 2259 people, who are predicted as churned but actually not churned and was loyal to bank.

# Creating workflow

```{r}
bank_churn_logistic_wkfl<- workflow() %>%
add_model(bank_churn_logistic_model) %>%
add_recipe(bank_churn_recipe)
bank_churn_logistic_wkfl
```

We have given instruction above in the model that to check the correlation for all numeric variables and keep the threshold limit as 0.8. We have also given instruction in the model to normalize all the numeric variables and set dummy to all nominal or character variables except the outcome variables because outcome is a character variable.

# Train the workflow

```{r}
bank_churn_logistic__wkfl_fit <- bank_churn_logistic_wkfl %>%
  last_fit( split = bank_churn_split)
bank_churn_logistic__wkfl_fit
```

# Calculating performance metrics on test data

```{r}
bank_churn_logistic__wkfl_fit %>%
   collect_metrics() 
```
The accuracy of the logistic regression model is 83.71% and roc-auc is 81,63%

# collecting predictions

```{r}
bank_churn_logistic_wkfl_fit_results<- bank_churn_logistic__wkfl_fit %>%
  collect_predictions()
bank_churn_logistic_wkfl_fit_results
```

# Creating custom metrics

```{r}
bank_churn_logistic_metrics <- metric_set(roc_auc,sens,spec,accuracy)
bank_churn_logistic_metrics
```

```{r}
bank_churn_logistic_wkfl_fit_results %>%
 bank_churn_logistic_metrics(truth = Exited, estimate = .pred_class, .pred_1)
```
The above are the metrics using logistic regression.

Let us develop random forest model and compare against logistic to see which model is more accuracte

# Machine learning models using random forest
```{r}
bank_churn_rf_model<- rand_forest(mtry =4,trees = 100, min_n =10) %>%
  set_engine('ranger') %>%
  set_mode('classification')
```
We have used 100 trees to create a model using random forest

# Training a forest
```{r}
bank_churn_fit_rf <- bank_churn_rf_model %>%
  fit (Exited ~ ., data = bank_churn_training_prep)
bank_churn_fit_rf
```

# Predicting outcome variables

```{r}
bank_churn_class_preds_rf <- predict(bank_churn_fit_rf, new_data = bank_churn_test_prep, type = "class")
bank_churn_class_preds_rf
```

The above are predicted outcomes using test set

# Estimated probabilities
```{r}
bank_churn_prob_preds_rf <- predict(bank_churn_fit_rf, new_data = bank_churn_test_prep, type = "prob")
bank_churn_prob_preds_rf
```

The above are the predicted probabilities using test data set.


# Combining results

```{r}
bank_churn_results_rf <- bank_churn_test_prep %>%
  bind_cols(bank_churn_class_preds_rf, bank_churn_prob_preds_rf)
bank_churn_results_rf
```
We have combined the predicted outcome and probabilities into the preprocessed test data set.

# Assessing model fit using confusion matrix
```{r}
bank_churn_results_rf %>%
  conf_mat(truth = Exited, estimate = .pred_class) %>%
autoplot(type = 'heatmap')
```
The above random forest model fit  is better than logistic model fit

# Correct predictions of test set
True negative is 1468 customers, who churned. True positive is 157 people, who was a loyal customer and did not churn. 

# Classification error of test set
False positive is 68 people, who are predicted as not churned but actually churned. False negative is 222 people, who are predicted as churned but actually not churned and was loyal to bank.

# Combining models and recipe
```{r}
bank_churn_wkfl_rf<- workflow() %>%
  add_model(bank_churn_rf_model) %>%
  add_recipe(bank_churn_recipe)
bank_churn_wkfl_rf
```

# Model fitting with workflow
```{r}
bank_churn_wkfl_fit_rf <- bank_churn_wkfl_rf %>%
  last_fit(split = bank_churn_split)
bank_churn_wkfl_fit_rf %>%
  collect_metrics()
```

We can see here the accuracy of the random forest model is 85.27% and roc_auc is 84.86%, which are better than logistic` model accuracy (83.71%) and roc_auc (81.63%).

# Collecting predictions
```{r}
bank_churn_wkfl_preds_rf <- bank_churn_wkfl_fit_rf %>%
  collect_predictions()
bank_churn_wkfl_preds_rf
```
# Confusion matrix
```{r}
conf_mat(bank_churn_wkfl_preds_rf, truth = Exited, estimate = .pred_class) %>%
  autoplot(type = 'heatmap')
```
We could that there is a reduction in both false positive and negative.

# Exploring custom metrics
```{r}
bank_churn_metrics_rf <- metric_set(roc_auc, sens, spec, accuracy)
bank_churn_wkfl_preds_rf %>%
bank_churn_metrics_rf(truth = Exited, estimate = .pred_class, .pred_1)
```
# Creating k-fold cross validation
```{r}
set.seed(222)
bank_churn_folds_rf <- vfold_cv(bank_churn_training, v = 10, strata = Exited)
bank_churn_folds_rf
```
Since random forest model is better than logistic model for prediction in terms of its accuracy and roc-auc, We take the random forest model to do cross validation and hyper parameter tuning to further increase the prediction accuracy.

We have used 10 times k-fold cross validation to do re-sampling.

# Model training with cross validation
```{r}
bank_churn_rs_fit_rf <-bank_churn_wkfl_rf %>%
  fit_resamples(resamples = bank_churn_folds_rf, metrics = bank_churn_metrics_rf)
bank_churn_rs_fit_rf %>%
  collect_metrics()
```


We can see above that accuracy of the model is improved to 86.30% from 85.27% and roc-auc is also improved to 85.10% from 84.86% using k-fold cross validation


# Detailed cross_validation results
```{r}
bank_churn_rs_metrics_rf <-bank_churn_rs_fit_rf %>%
  collect_metrics(summarize = FALSE)
bank_churn_rs_metrics_rf 
```



# Summarizing cross validation results
```{r}
bank_churn_rs_metrics_rf %>%
  group_by(.metric) %>%
  summarize(min= min(.estimate),
            median = median(.estimate),
            max = max(.estimate),
            sd = sd(.estimate))
```

# Hyper parameter tuning
```{r}
bank_churn_rf_tune_model <- rand_forest(mtry = tune(), trees = tune(), min_n = tune()) %>%
  set_engine('ranger') %>%
  set_mode('classification')
bank_churn_rf_tune_model
```
# Creating tuning workflow
```{r}
bank_churn_tune_wkfl_rf <- bank_churn_wkfl_rf %>%
  update_model(bank_churn_rf_tune_model)
bank_churn_tune_wkfl_rf
```


# Identifying hyperparameters
```{r}
parameters(bank_churn_rf_tune_model)
```
# Hyperparameter tuning with cross validation
```{r}
bank_churn_rf_tuning <- bank_churn_tune_wkfl_rf %>%
  tune_grid(resamples= bank_churn_folds_rf,  metrics = bank_churn_metrics_rf)
bank_churn_rf_tuning
```                                                                                                                                                               



# Exploring tuning results
```{r}
bank_churn_rf_tuning %>%
  collect_metrics()
```

# Detailed tuning results
```{r}
bank_churn_rf_tuning %>%
  collect_metrics(summarize = FALSE)
```

# Exploring tuning results
```{r}
bank_churn_rf_tuning %>%
  collect_metrics(summarize = FALSE) %>%
  filter(.metric == 'roc_auc') %>%
  group_by (id) %>%
  summarize( min_roc_auc = min(.estimate),
             median_roc_auc = median(.estimate),
             max_roc_auc = max(.estimate))
```

# Viewing the best performing model
```{r}
bank_churn_rf_tuning %>%
  show_best(metric = 'roc_auc', n =5)
```

Model 8 is the best model

# Selecting the best model
```{r}
bank_churn_best_rf_model <- bank_churn_rf_tuning %>%
  select_best(metric = 'roc_auc')
bank_churn_best_rf_model 
```

The best parameters are mtry is 4, trees is 1848 and min_n is 31 and the best model is Preprocessor1_Model08

# Finalizing the workflow
```{r}
final_bank_churn_wkfl_rf <- bank_churn_tune_wkfl_rf %>%
  finalize_workflow(bank_churn_best_rf_model)
final_bank_churn_wkfl_rf
```


# Model fitting
```{r}
bank_churn_final_fit_rf <- final_bank_churn_wkfl_rf %>%
  last_fit(split = bank_churn_split)
bank_churn_final_fit_rf %>%
  collect_metrics()

```


We can see above that accuracy and roc-auc (87.05% & 87.99% respectively) are improved compared to the model without tuning. 

# collecting predictions
```{r}
bank_churn_prediction_rf<- bank_churn_final_fit_rf %>%
  collect_predictions()
bank_churn_prediction_rf
```


```{r}
conf_mat(bank_churn_prediction_rf, truth = Exited, estimate = .pred_class) %>%
  autoplot(type = 'heatmap')
```


# Correct predictions of test set
True negative is 1485 customers, who churned. True positive is 182 people, who was a loyal customer and did not churn. 

# Classification error of test set
False positive is 51 people, who are predicted as not churned but actually churned. False negative is 197 people, who are predicted as churned but actually not churned and was loyal to bank.

Almost 80% of the customers churned